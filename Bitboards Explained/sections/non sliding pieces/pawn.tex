% !TeX spellcheck = en_US
\subsubsection{Pawn}
\begin{figure}[H]
	\centering
	\subfloat[Pawn movement: A pawn can move to the square directly in front of itself, if that square is clear. A pawn on its starting rank has the option of moving two squares.]{
	%
		\newchessgame
		\setchessboard{showmover=false, smallboard}
		\chessboard[setpieces={pa6, Pc4, Pe2, pg7},
			pgfstyle=straightmove,
			shortenstart=1ex,
			arrow=to,
			markmoves={
			a6-a5,
			c4-c5,
			e2-e3,
			e2-e4,
			g7-g6,
			g7-g5
			}
		]
		\label{fig: non capture pawn moves}
	%
	}
	\hspace{0.5cm}
	\subfloat[The white pawn at d5 may capture either the black rook at c6 or the black knight at e6, but not the bishop at d6, which blocks the pawn's ability to move directly forward.]{
	%
		\newchessgame
		\setchessboard{showmover=false, smallboard}
		\chessboard[setpieces={Pd5, rc6, bd6, ne6},
			pgfstyle=straightmove,
			shortenstart=0.3ex,
			shortenend=1ex,
			color=green,
			arrow=to,
			markmoves={
				d5-c6,
				d5-e6
			}
		]
		\label{fig: capture pawn moves}
	%
	}
		\vfill
		\hspace{0.5cm}
	\subfloat[\textit{En passant} capture, assuming that the black pawn has just moved from c7 to c5. The white pawn moves to the c6-square and the black pawn is removed.]{
	%
		\newchessgame
		\setchessboard{showmover=false, smallboard}
		\chessboard[setpieces={Pd5, pc5},
			pgfstyle=straightmove,
			shortenend=1ex,
			color=blue,
			arrow=to,
			markmoves={c7-c5},
			color=green,
			shortenstart=0.3ex,
			markmoves={d5-c6}
		]
		\label{fig: en passant capture}
	%
	}
	\captionof{figure}{Pawn movement.}
\end{figure}
%
Move generating for pawns is more difficult compared to other pieces. Pawns are the only piece that can move into one direction.
Pawns can only capture diagonally, one square forward and to the left or right.
Another unusual move is the \textit{en passant} capture.
When an enemy pawns moves forward two squares instead of one, the square behind the pawn that just made this move, becomes a possible move for the enemy pawn. Note that the pawn that moved two squares passed over a square that was attack by an enemy pawn.
That enemy pawn, which would have been able to capture the moving pawn had it advanced only one square, is entitled to capture the moving pawn ``in passing'' as if it had advanced only one square.
The capturing pawn moves into the empty square over which the moving pawn passed, and the moving pawn is removed from the board.
Note that an en passant capture must take place directly when the enemy pawn moves two square forward. 
If a player chose not to play the en passant move, the move cannot be applied to the same pawn when the player has turn again.
Pawns can also promote into other pieces when reaching the opposite side of the board (the first rank of the other player).
When the a pawn reaches this position, it is promoted into another piece of that players's choice: a queen, rook, bishop or knight of the same color. 
Most of the times, players choose to promote their pawn into a queen.
When an other piece is chosen, it is also called ``underpromotion''.

Now we know the possible moves of the pawn, lets dive into the move generation using bitboards.
Let first talk about the pawn pushes, which do not involve captures.
To check whether pawn can move forward one square is easily determined by shifting to the North when the pawn is white, and to the South when the pawn is black. Finally, we intersect the resulting bitboard with the bitboard containing all of empty squares. The code is shown in \Cref{fig: pawn single push}.
%
\begin{listing}
\begin{minted}{c++}
uint64_t whitePawnsSinglePushMoves(uint64_t whitePawns, uint64_t emptySquares){
	return northOne(whitePawns) & emptySquares;
}

uint64_t blackPawnsSinglePushMoves(uint64_t blackPawns, uint64_t emptySquares){
	return southOne(blackPawns) & emptySquares;
}
\end{minted}
\captionof{listing}{Calculation of the single push squares for the pawns.}
\label{fig: pawn single push}
\end{listing}
%
For calculating the double push targets, we shift the single push square in the right direction and check whether the new rank of the pawn is empty (rank 4 for white pawns, rank 5 for black pawns). The code is shown in \Cref{fig: pawns double push}.
%
\begin{listing}
\begin{minted}{c++}
uint64_t whitePawnsDoublePushMoves(uint64_t whitePawns, uint64_t emptySquares){
	// mask in which the bits on rank 4 are turned on.
	const uint64_t rank4 = 0x00000000FF000000;
	uint64_t singlePushs = whitePawnsSinglePushMoves(whitePawns, emptySquares);
	return northOne(singlePushs) & rank4 & emptySquares;
}

uint64_t blackPawnsDoublePushMoves(uint64_t blackPawns, uint64_t emptySquares){
	// mask in which the bits on rank 5 are turned on.
	const uint64_t rank5 = 0x000000FF00000000;
	uint64_t singlePushs = blackPawnsSinglePushMoves(blackPawns, emptySquares);
	return southOne(singlePushs) & rank5 & emptySquares;
}
\end{minted}
\captionof{listing}{Calculation of the double push squares for the pawns.}
\label{fig: pawns double push}
\end{listing}
%
To get the pawns that are able to push one square, we shift the free squares towards the rank closest to the player and intersect the result with all the pawns.
We describe the calculations to get the set of source squares of pawns being able to double push for white pawns:
We start from the rank 4 for white pawns.
We shift the rank, intersected with the empty squares set, towards rank 3. 
Now we intersect it again with the empty squares to verify if rank 3 is empty. Finally, we call \texttt{whitePawnsAbleToPush()} with the white pawns and this calculated empty rank 3. 
For black pawns, the calculation can be done similar for black.
The code snippet is shown in \Cref{fig: white pawns able to push}.
%
\begin{listing}
\begin{minted}{c++}
uint64_t whitePawnsAbleToPush(uint64_t whitePawns, uint64_t emptySquares){
	return southOne(emptySquares) & whitePawns;
}

uint64_t whitePawnsAbleToDoublePush(uint64_t whitePawns, uint64_t emptySquares) {
	const uint64_t rank4 = 0x00000000FF000000;
	uint64_t emptyRank3 = southOne(emptySquares & rank4) & emptySquares;
	return whitePawnsAbleToPush(whitePawns, emptyRank3);
}
\end{minted}
\captionof{listing}{Calculation of the source squares of the white pawns that are able to double push.}
\label{fig: white pawns able to push}
\end{listing}
%
Since double pushing triggers determination of en passant target square, it makes sense to serialize both sets separately for different move encoding. The same applies to promotion moves.

